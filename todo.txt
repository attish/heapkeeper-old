* <#1> Generator.posts_to_html should be refactored.
    * the post HTML generator should now about the index to allow #2
    * generating a file different from index.html

* Tests:
    * Generator: posts_to_html (precond: #1)
    * Generator.index: more tests.
        * 'write_date'
        * 'write_toc'
        * cycles
    * heapia
    * Post.load
    * heapmanip.Post.{set_tags, remove_tag}
    * doc&test: MailDB.{children, roots, threads}
        * dependencies?
        * Html.table

* docstrings:
    * types into generator methods
    * object instead of "something" and "andthing"
    * extracting pseudo-types (like PrePostSet and SectionOptions)

* Developer Guide
    * architecture
        * relation of Post, MailDB and PostSet
        * by-request philosoply
        * touch-system
    * performance improvement possibilities (iterators)
    * using wrappers to protect e.g. MailDB.posts()
    * consistent terminology: previous, parent or cause? next, child or
      consequence?

* heapia: atr, rt, rtr, sr, str_ are almost the same, they could use the same
  function and contain only the differences:

    def rtr(pps, tags):
        """..."""
        tag_operation(lambda post, tags: post.set_tags(set(post.tags()) - tags))

* STAR should be renamed


+ MailDB.reload, and also an interface to heapia

+ <#2> Post generator: (precond: #1)
    + parent, children into Post HTML (easy)
    + put prev and next links into Post HTML (the post generator should know
      about the generated index)
    + "back to thread" link.
      HTML-id-s should be put to each thread in the index to implement this.
      Idea: would it make sense to put id-s to each post in the index? -- Csabi

+ Thread HTML-s (precond: #1): every thread could have an HTML. Threads could
  be identified by the id of their root post.

+ Index generator: now the user defines how to show the date in index.html; the
  same could be done for other fields (e.g. the user could write a function that
  creates 'very long...' from 'very long subject')

+ Post body parsing:
    This should be discussed.
    + creating real links form http://... text
    + creating links from post-references. Idea:
      Original post: <<<!post: 123>>>
      In Post HTML: <a href="123.post">&lt;&lt;&lt;post: 123&gt;&gt;&gt;</a>
    + any inline links (instead of cites):
      Original post: what about [this|http://...] thing?
      In Post HTML:  what about <a href="http://...">this</a> thing?
    + creating flags from <<<metatext>>> (e.g. todo flag)
        * How to show the flags like "todo" in the index? Maybe they should be
         tags, and not flags?
    + dealing with cites
    + showing the authors of the quotes
    + do automatic actions based on metatext? E.g. <<<!delete>>>,
      <<<!addtagtothread unix>>>
    + formatting _underline_ and *bold* text: do we want it? (probably not)
    + the post's HTML could contain the whole thread of the post below the post
      itself?
    + post references for non-existent posts with explicit id-s:
      Original post1: <<<post:id=boring_stuff>>>
      Original post2: As I said in [this|post:id=boring_stuff] mail...
      Post2 in HTML:  what about <a href="http://...">this</a> thing?

+ Generator: different colours for the posts that are not in a section but
  their thread is

+ <#3> PostSetMapDelegate:
  MailDB.postset([p1, p2, p3]).map.heapid()  -->  ['1', '2', '3']

+ <#4> PostSetGrepDelegate (precond: #3): it would be similar to grep (but
  smarter of course in our domain):

  ps.grep('unix stuff')  -->  [('12', ['I said that unix stuff, you know']),
                               ('13', ['> I said that unix stuff, you know'],
                                       'Yes, but your unix stuff is very'])]
  The quote could be excluded from the result of grep.

  It could be implemented with the Map delegate:

    def find_lines(regex, s):
        """Returns the lines of s that contain the regex."""
        return [ line for line in s if re.search(regex, s) ]
    def grep(ps, regex): # ps=postset
        def find_lines_in_post(regex):
            def f(post):
                """Returns None if regex is not in the post's body; otherwise
                returns a tuple with the heapid of the post and a list of the
                hits"""
                lines = find_lines(regex, post.body())
                if lines == []:
                    return None
                else:
                    return (post.heapid(), lines)
            return f
        return [ result for result in ps.map(find_lines_in_post('unix stuff'))\
                        if result != None ]

    grep(ps, 'unix stuff')  -->  as in th previous example

+ Integrating the search into Vim. (precond: #4)
    :h setqflist()

    Hint (Vimscript code):
    call setqflist([{'filename':'12.mail', 'lnum':'4',
                     'text':'I said that unix stuff, you know'},
                    {'filename':'13.mail', 'lnum':'1',
                     'text':'> I said that unix stuff, you know'},
                    {'filename':'13.mail', 'lnum':'2',
                     'text':'Yes, but your unix stuff is very'}])

+ Model: References among posts (beyond in-reply-to)

+ tags, flags
    + Implementing tags and flags as frozensets
    + Tags dependencies, TagInfo class
    + Flag: New-thead flag to indicate that the email begins a new thread.
      Post.inreplyto should return None if the post has a new-thread flag.
      Post.real_inreplyto would be the current Post.inreplyto.
    + should the tags be case insensitive?
    + tag aliases: py = python

* CSS
    * Try out including heapindex.css into the customized heapindex.css
    * Write about CSS into the user documentation (currently you have to make a
      symlink by hand to get it work; we should say something about this)

+ Post: cleanup functionality. Something like Post.normalize_subject, but with
  a broader scope.
    + deleting in-reply-to if the referenced post is not in the DB

* Post, MailDB: a better system for 'touch': it should know what should be
  recalculated and what should not be. It would improve only efficiently, not
  usability.

+ heapia could print affected emails after executing a command. The
  touch-system could be used to make an approximation, but probably the heapia
  improved to reach a 100% correct solution. E.g. condiser setting subject X
  for a post which already has that subject. The touch-system will say it
  changed; I think the Post should not care about whether it really changed or
  nor that, for efficiency reasons. On the other hand, the implementation of
  heapia would be much less elegant if it monitored actual changes in posts.
  -- Csabi

+ Downloading emails since given date.
  Workaround: if we go to the heap account regularly and archive the emails in
  the inbox, downloading new mail will remain fast.

+ MailDB.sync: unison-like method to synchronize the data between the MailDB in
  the memory and the mail files on the disk

* Migration to Python 3

+ Inline posts: the body of the specified posts could be shown in the index.
  JavaScript (or CSS?) could be used for folding the inline posts.

* Distant future: use Django or some other web framework to manipulate the heap
  instead of heapia.

Next free id: #5
